
《Client side caching in Redis 6》中提到redis 接下来的一个重点是配合客户端，因为客户端缓存显而易见的可以减轻 redis 的压力，速度也快很多。大公司或多或少都有实现这种应用端缓存的机制，antirez 想通过 server 端的一些设计来减少客户端缓存实现的复杂度和成本，甚至不惜在 redis 协议上做修改。

# 一、为什么要使用客户端缓存？

Redis 有其性能上限，并且访问 Redis 必然有一定的网络 I/O 以及序列化反序列化损耗。所以，往往会引入本地（客户端）缓存，将最热的数据存储在本地，进一步加快访问速度。

客户端缓存是一种用于创建高性能服务的技术。它利用应用服务器(与数据库节点相比，应用服务器通常是不同的计算机)中的可用内存，以便将数据库信息的某些子集直接存储在应用程序端。用于本地缓存的内存可能不是很大，同时但与访问数据库等网络服务相比，访问本地计算机内存所需的时间数量级较小。由于经常有相同比例的数据被频繁访问，这种模式可以大大减少应用程序获取数据的延迟，同时减少数据库端的负载。

此外，有许多数据集中的项目变化很少。例如，社交网络中的大多数用户帖子要么是不变的，要么很少被用户编辑。除此之外，通常只有一小部分帖子非常受欢迎，这要么是因为一小部分用户有很多关注者，要么是因为最近的帖子有很多可见性，很明显这种模式非常有用。

不使用客户端缓存时，查询数据时，会直接访问redis。像下面这样：
```text
+-------------+                                +----------+
|             | ------- GET user:1234 -------> |          |
| Application |                                |   Redis  |
|             | <---- username = Alice ------- |          |
+-------------+                                +----------+
```
当使用客户端缓存时，客户端将会在自身内存中存储最经常的查询，因此在后续的查询时，会先查看本地缓存是否存在被查询的数据，没有才会向Redis发起查询请求。
```text
+-------------+                                +----------+
|             |                                |          |
| Application |       ( No chat needed )       |   Redis  |
|             |                                |          |
+-------------+                                +----------+
| Local cache |
|             |
| user:1234 = |
| username    |
| Alice       |
+-------------+
```

总而言之，使用客户端缓存有下面的优点：
- 数据访问延时更低。
- Redis数据库接收到的请求会变少，因为能够允许较少的服务器提供服务。

# 二、使用客户端缓存的两个问题

一个问题是，当Redis服务器中的数据更新了，但是客户端缓存可能一直保存旧的数据。例如客户端缓存了数据user:1234，用户可能修改了用户名，然而客户端还是保存的旧的user:1234的值。

上述的问题容易解决，只需要客户端为缓存内容设置最大生存时间，一旦过了生存时间，客户端缓存的内容失效即可。

更复杂的模式利用 Pub/Sub 系统向侦听客户机发送无效消息。这可以实现，但是从所使用的带宽的角度来看，这是复杂和昂贵的，因为这种模式通常涉及向应用程序中的每个客户端发送无效消息，即使某些客户端可能没有任何无效数据的副本。此外，每个改变数据的应用程序查询都需要使用 PUBLISH 命令，从而使数据库花费更多的 CPU 时间来处理这个命令。

# 三、Redis提供的两种客户端缓存机制

Redis提供的客户端缓存机制叫做 Tracking。有两种模式：

| 模式         | 描述                                                                                                                                                                                             | 优缺点 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------ | 
| default      | 服务端会记录某个客户端具体访问过哪一些 key，当这些 key 对应的值发生变化时，会发送失效消息给这些客户端。会在服务端消耗一些内存，但是发送失效消息的范围，被限制在了客户端存储了的 key 的集合范围内 |        | 
| broadcasting |                                                                                                                                                                                                  |        | 

## 默认模式

下面是一个默认模式的简单例子：
-   Client 1 `->` Server: CLIENT TRACKING ON
-   Client 1 `->` Server: GET foo
-   (The server remembers that Client 1 may have the key "foo" cached)
-   (Client 1 may remember the value of "foo" inside its local memory)
-   Client 2 `->` Server: SET foo SomeOtherValue
-   Server `->` Client 1: INVALIDATE "foo"

Redis使用2个重要手段来支持默认模式的正常运行：

Redis服务器维护了一个 Invalidation表。 









只使用 Redis 分布式缓存时，遇到数据更新时，应用程序更新完 MySQL 中的数据，可以直接将 Redis 中对应缓存失效掉，保持数据的一致性。

而进程内缓存的数据一致性比分布式的缓存面临更大的挑战。数据更新的时候，如何通知其他进程也更新自己的缓存呢?

如果按照分布式缓存的思路，我们可以设置极短的缓存失效时间，这样不必实现复杂的通知机制。

但是不同进程内的数据依然会面临不一致的问题，并且不同进程缓存失效时间不统一，同一个请求到了不同的进程，可能出现反复幻读的情况。



